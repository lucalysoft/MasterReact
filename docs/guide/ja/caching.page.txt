ページキャッシュ
============

ページキャッシュはページの内容全てをキャッシュすることを指します。
ページキャッシュは、別の場所で発生することがあります。
たとえば、適切なページヘッダーを使えば、クライアントブラウザは
ページを有効期限付きでキャッシュするでしょう。
また、ウェブアプリケーション自身は、ページコンテンツをキャッシュとして
保存できます。このサブセクションでは、後者のやり方について解説します。

ページキャッシュは [フラグメントキャッシュ](/doc/guide/caching.fragment) の
特殊な形と捉えられます。ページの内容の多くはビューにレイアウトを適用し
生成されるため、レイアウト中で単純に [beginCache()|CBaseController::beginCache]
と [endCache()|CBaseController::endCache] を呼び出しても動きません。
なぜなら、レイアウトは、コンテンツビューが評価された後に、
[CController::render()] メソッド中で適用されるからです。

ページ全体をキャッシュするには、ページ内容を生成するアクションの実行を
スキップしなければいけません。
これを行うために、[COutputCache] を [フィルタ](/doc/guide/basics.controller#フィルタ)
アクションとして使用出来ます。
キャッシュフィルタの設定方法を下記に示します:

~~~
[php]
public function filters()
{
	return array(
		array(
			'COutputCache',
			'duration'=>100,
			'varyByParam'=>array('id'),
		),
	);
}
~~~

上記フィルタ設定は、コントローラのすべてのアクションに適用されます。
プラスの演算子だけを使い、1つかいくつかのアクションのみに制限することも
できます。詳細については、[フィルタ](/doc/guide/basics.controller#フィルタ)
を参照してください。

> Tip|ヒント:  [COutputCache] は [CFilterWidget] より継承されているため、
[COutputCache] をフィルタとして使用できます。
実際、ウィジェットの動作はフィルタにとても似ています:
ウィジェット（フィルタ）は、それに含まれているコンテンツ（アクション）が
評価される前に動作が始まり、そして、含まれているコンテンツ（アクション）が
評価された後に、ウィジェット（フィルタ）が終了します。

HTTP キャッシュ
------------
Yii は、アクションの出力の単純なキャッシュに加えて、バージョン 1.1.11 において
[CHttpCacheFilter] を導入しました。このフィルターは、前述のヘッダ（ページの内容が
最後のリクエストの時から変更されていないことをクライアントに通知するためのヘッダ）を
設定する手助けをしてくれます。これによってサーバーはコンテンツを再送しなくてよくなります。
[CHttpCacheFilter] は [COutputCache] と同じ様にして設定することが出来ます。
~~~
[php]
public function filters()
{
    return array(
        array(
            'CHttpCacheFilter + index',
            'lastModified'=>Yii::app()->db->createCommand("SELECT MAX(`update_time`) FROM {{post}}")->queryScalar(),
        ),
    );
}
~~~
上記のコードは、`Last-Modified` ヘッダを投稿記事が更新された日時に設定します。
また、遅延評価のためには、[CHttpCacheFilter::lastModifiedExpression] を利用することが出来ます。

> Tip|ヒント: [CHttpCacheFilter::lastModifiedExpression] と [CHttpCacheFilter::lastModified]
は、両方とも、Unix タイムスタンプを表わす整数か、任意の形式の日付文字列を受け入れることが
出来ます。後者については、[strtotime()](http://php.net/manual/function.strtotime.php) によって
解釈できる形式である限り、更なる変換は必要ありません。

"Entity Tag" (または略して `ETag`) ヘッダも同様に、[CHttpCacheFilter::etagSeed] および
[CHttpCacheFilter::etagSeedExpression] によって設定することが出来ます。
両方ともシリアライズされた値（従って単一の値を使うことも、配列を使うことも出来ます）
から印字可能な base64 エンコードされた SHA1 ハッシュを生成して、`ETag` ヘッダの内容として
使用します。これは [Apache ウェブサーバ](http://httpd.apache.org) や他のサーバが
ETag を生成する方法とは異なります。しかし、この手法は完璧に RFC にのっとっていますし、
フレームワークでの使用にはより適したものであることが分っています。

> 注意: [RFC 2616, section 13.3.4](http://tools.ietf.org/html/rfc2616#section-13.3.4)
を遵守するために、[CHttpCacheFilter] は、両方とも生成出来る場合には、`ETag` *および*
`Last-Modified` の両方のヘッダを送出します。結果として、クライアントに送られたとき、
両方がキャッシュ評価に使用されます。

"Entity Tag" はハッシュであるため、`Last-Modified` ヘッダよりも、複雑あるいは
精密なキャッシュ制御を可能にします。例えば、サイトが別のテーマにエンティティ
Since entity tags are hashes, they allow more complex and/or more precise
caching strategies than `Last-Modified` headers. For instance, an ETag can be
invalidated if the site has switched to another theme.

> Tip: Expensive expressions for [CHttpCacheFilter::etagSeedExpression] may
defeat the purpose of [CHttpCacheFilter] and introduce unnecessary overhead,
since they need to be re-evaluated on every request. Try to find a simple
expression that invalidates the cache if the page *content* has been modified.

### SEO Implications
Search engine bots tend to respect cache headers. Since some crawlers have a
limit on how many pages per domain they process within a certain time span,
introducing caching headers may help indexing your site as they reduce the
number of pages that need to be processed.

It seems that the `Last-Modified` header is favored by most search engines.
Most notably, [Google](http://www.google.com) uses the content of this header
on its result page.

<div class="revision">$Id: caching.page.txt 1014 2009-05-10 12:25:55Z qiang.xue $</div>