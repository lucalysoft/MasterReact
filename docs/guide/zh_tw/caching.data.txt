資料快取
============

資料快取即儲存一些 PHP 變數到快取中，以後再從快取中取出來。出於此目的，快取元件的基礎類別 [CCache]
提供了兩個最常用的方法： [set()|CCache::set] 和 [get()|CCache::get]。

要在快取中儲存一個變數 `$value` ，我們選擇一個唯一 ID 並調用 [set()|CCache::set] 儲存它：

~~~
[php]
Yii::app()->cache->set($id, $value);
~~~

快取的資料將一直留在快取中，除非它由於某些快取策略（例如快取空間已滿，舊的資料被刪除）而被清除。
要改變這種行為，我們可以在調用  [set()|CCache::set]  的同時提供一個過期參數，這樣在設定的時間段之後，快取資料將被清除：

~~~
[php]
// 值 $value 在快取中最多保留 30 秒
Yii::app()->cache->set($id, $value, 30);
~~~

稍後當我們需要存取此變數時（在同一個或不同的 Web 請求中），就可以通過 ID 調用 [get()|CCache::get] 從快取中將其取回。
如果返回的是 false，表示此值在快取中不可用，我們應該重新產生它。

~~~
[php]
$value=Yii::app()->cache->get($id);
if($value===false)
{
	// 因為在快取中沒找到 $value ，重新產生它 ，
	// 並將它存入快取以備以後使用：
	// Yii::app()->cache->set($id,$value);
}
~~~

為要存入快取的變數選擇 ID 時，要確保此 ID 對應用程式中所有其他存入快取的變數是唯一的。
而在不同的應用程式之間，這個 ID 不需要是唯一的。快取元件具有足夠的智慧區分不同應用程式中的 ID。

一些快取儲存裝置，例如 MemCache, APC, 支援以批次模式取得多個快取值。這可以減少取得快取資料時帶來的開銷。Yii 提供了一個名為 [mget()|CCache::mget] 的方法來完成此功能。如果底層快取儲存裝置不支援此功能，[mget()|CCache::mget] 依然可以模擬實現它。

要從快取中清除一個快取值，調用 [delete()|CCache::delete]; 要清除快取中的所有資料，調用 [flush()|CCache::flush]。
當調用 [flush()|CCache::flush] 時一定要小心，因為它會同時清除其他應用程式中的快取。

> Tip|提示: 由於 [CCache] 實現了 `ArrayAccess`，快取元件也可以像一個陣列一樣使用。下面是幾個例子：
> ~~~
> [php]
> $cache=Yii::app()->cache;
> $cache['var1']=$value1;  // 相當於: $cache->set('var1',$value1);
> $value2=$cache['var2'];  // 相當於: $value2=$cache->get('var2');
> ~~~

快取相依性
----------------

除了過期設置，快取資料也可能會因為相依性條件發生變化而失效。例如，如果我們快取了某些文件的內容，而這些文件發生了改變，我們就應該讓快取的資料失效，
並從文件中讀取最新內容而不是從快取中讀取。

我們將一個相依性關係顯示為一個 [CCacheDependency] 或其子類別的實體。
當調用 [set()|CCache::set] 時，我們連同要快取的資料將其一同傳入。

~~~
[php]
// 此值將在 30 秒後失效
// 也可能因相依性的文件發生了變化而更快失效
Yii::app()->cache->set($id, $value, 30, new CFileCacheDependency('FileName'));
~~~

現在如果我們通過調用 [get()|CCache::get] 從快取中取得 `$value` ，相依性關係將被檢查，如果發生改變，我們將會得到一個 false 值，表示資料需要被重新產生。

下面是可用的快取相依性的簡要說明：

   - [CFileCacheDependency]: 如果文件的最後修改時間發生改變，則相依性改變。

   - [CDirectoryCacheDependency]: 如果目錄和其子目錄中的文件發生改變，則相依性改變。

   - [CDbCacheDependency]: 如果指定 SQL 語句的查詢結果發生改變，則相依性改變。

   - [CGlobalStateCacheDependency]: 如果指定的全域狀態發生改變，則相依性改變。全域狀態是應用程式中的一個跨請求、跨會話的變數。它是通過 [CApplication::setGlobalState()] 定義的。

   - [CChainedCacheDependency]: 如果鏈中的任何相依性發生改變，則此相依性改變。

   - [CExpressionDependency]: 如果指定的 PHP 表達式的結果發生改變，則相依性改變。


Query Caching
-------------

Since version 1.1.7, Yii has added support for query caching.
Built on top of data caching, query caching stores the result of a DB query
in cache and may thus save the DB query execution time if the same query is requested
in future, as the result can be directly served from the cache.

> Info: Some DBMS (e.g. [MySQL](http://dev.mysql.com/doc/refman/5.1/en/query-cache.html))
> also support query caching on the DB server side. Compared with the server-side
> query caching, the same feature we support here offers more flexibility and
> potentially may be more efficient.


### Enabling Query Caching

To enable query caching, make sure [CDbConnection::queryCacheID] refers to the ID of a valid
cache application component (it defaults to `cache`).


### Using Query Caching with DAO

To use query caching, we call the [CDbConnection::cache()] method when we perform DB queries.
The following is an example:

~~~
[php]
$sql = 'SELECT * FROM tbl_post LIMIT 20';
$dependency = new CDbCacheDependency('SELECT MAX(update_time) FROM tbl_post');
$rows = Yii::app()->db->cache(1000, $dependency)->createCommand($sql)->queryAll();
~~~

When running the above statements, Yii will first check if the cache contains a valid
result for the SQL statement to be executed. This is done by checking the following three conditions:

- if the cache contains an entry indexed by the SQL statement.
- if the entry is not expired (less than 1000 seconds since it was first saved in the cache).
- if the dependency has not changed (the maximum `update_time` value is the same as when
the query result was saved in the cache).

If all of the above conditions are satisfied, the cached result will be returned directly from the cache.
Otherwise, the SQL statement will be sent to the DB server for execution, and the corresponding
result will be saved in the cache and returned.


### Using Query Caching with ActiveRecord

Query caching can also be used with [Active Record](/doc/guide/database.ar).
To do so, we call a similar [CActiveRecord::cache()] method like the following:

~~~
[php]
$dependency = new CDbCacheDependency('SELECT MAX(update_time) FROM tbl_post');
$posts = Post::model()->cache(1000, $dependency)->findAll();
// relational AR query
$posts = Post::model()->cache(1000, $dependency)->with('author')->findAll();
~~~

The `cache()` method here is essentially a shortcut to [CDbConnection::cache()].
Internally, when executing the SQL statement generated by ActiveRecord, Yii will
attempt to use query caching as we described in the last subsection.


### Caching Multiple Queries

By default, each time we call the `cache()` method (of either [CDbConnection] or [CActiveRecord]),
it will mark the next SQL query to be cached. Any other SQL queries will NOT be cached
unless we call `cache()` again. For example,

~~~
[php]
$sql = 'SELECT * FROM tbl_post LIMIT 20';
$dependency = new CDbCacheDependency('SELECT MAX(update_time) FROM tbl_post');

$rows = Yii::app()->db->cache(1000, $dependency)->createCommand($sql)->queryAll();
// query caching will NOT be used
$rows = Yii::app()->db->createCommand($sql)->queryAll();
~~~

By supplying an extra `$queryCount` parameter to the `cache()` method, we can enforce
multiple queries to use query caching. In the following example, when we call `cache()`,
we specify that query caching should be used for the next 2 queries:

~~~
[php]
// ...
$rows = Yii::app()->db->cache(1000, $dependency, 2)->createCommand($sql)->queryAll();
// query caching WILL be used
$rows = Yii::app()->db->createCommand($sql)->queryAll();
~~~

As we know, when performing a relational AR query, it is possible several SQL queries will
be executed (by checking the [log messages](/doc/guide/topics.logging)).
For example, if the relationship between `Post` and `Comment` is `HAS_MANY`,
then the following code will actually execute two DB queries:

- it first selects the posts limited by 20;
- it then selects the comments for the previously selected posts.

~~~
[php]
$posts = Post::model()->with('comments')->findAll(array(
	'limit'=>20,
));
~~~

If we use query caching as follows, only the first DB query will be cached:

~~~
[php]
$posts = Post::model()->cache(1000, $dependency)->with('comments')->findAll(array(
	'limit'=>20,
));
~~~

In order to cache both DB queries, we need supply the extra parameter indicating how
many DB queries we want to cache next:

~~~
[php]
$posts = Post::model()->cache(1000, $dependency, 2)->with('comments')->findAll(array(
	'limit'=>20,
));
~~~


### Limitations

Query caching does not work with query results that contain resource handles. For example,
when using the `BLOB` column type in some DBMS, the query result will return a resource
handle for the column data.

Some caching storage has size limitation. For example, memcache limits the maximum size
of each entry to be 1MB. Therefore, if the size of a query result exceeds this limit,
the caching will fail.


<div class="revision">$Id$</div>